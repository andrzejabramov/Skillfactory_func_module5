# Task1_fibonacci

В этом задании вам предстоит поработать со второй классической задачей в контексте рекурсивных функций — числами Фибоначчи.

Числа Фибоначчи — это последовательность чисел, в которой каждое следующее число в ряду является суммой двух предыдущих чисел. Первые два числа в этой последовательности — это 0 и 1.

Например, вот начало последовательности Фибоначчи: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34 и так далее. Каждое число в этой последовательности, начиная с третьего, — это сумма двух предыдущих чисел.

1.Алгоритм вычисления n-ного числа Фибоначчи:
Определите два базовых случая: -вложенный Если n меньше или равно 0, верните 0. -вложенный Если n равно 1, верните 1.

2.Иначе, вызовите функцию рекурсивно для (n-1)-го и (n-2)-го числа Фибоначчи и верните их сумму.

Ваша задача — определить функцию fibonacci для вычисления n-ного числа Фибоначчи.

Пример работы программы:


print(fibonacci(5)) 
#### #5
print(fibonacci(7)) 
#### #13
print(fibonacci(8)) 
#### #21

-----------------------------
# Task2_pallindrome

С помощью рекурсии определите, является ли слово палиндромом.
Для этого реализуйте функцию is_palindrome, которая принимает строку s. Если слово — палиндром, функция должна возвращать True, если не палиндром — False.
Пример работы программы:


print(is_palindrome('racecar'))
#### True
print(is_palindrome('gong'))
#### False

-------------------------------
# Task3_binnary

Ваша задача — реализовать алгоритм бинарного поиска. Он значительно экономит время, ускоряя поиск элемента в отсортированном списке или массиве.

Бинарный поиск позволяет сразу исключить половину элементов, в то время как простой линейный поиск проверяет каждый элемент по очереди. Это особенно полезно при работе с большими данными.

Нужно, используя рекурсию, перевести на язык Python следующий алгоритм:

1.Определите средний элемент отсортированного списка.
2.Если средний элемент является искомым значением, то поиск завершён.
3.Если искомое значение меньше среднего элемента, повторите поиск в левой половине списка.
4.Если искомое значение больше среднего элемента, повторите поиск в правой половине списка.
5.Если список пуст (то есть начальная позиция больше конечной), значит, искомого элемента в списке нет.

Определите функцию binary_search, которая принимает первым аргументом список (он уже отсортирован), а вторым — элемент, который необходимо найти.

Функция должна возвращать True, если такой элемент есть в списке, и False — если его нет.

Пример работы программы:


print(binary_search([1, 2, 3, 4, 5], 4))
#### #True
print(binary_search([1, 2, 3, 4, 5], 6))
#### #False

--------------------------
# Task4

Условие: Во многих веб-приложениях URL-ы могут быть структурированы последовательно (например, /product/1, /product/2 и так далее). Создайте функцию-генератор generate_urls, которая будет возвращать последовательные URL-ы для заданного шаблона и диапазона чисел.

Пример работы программы:


url_generator = generate_urls("/product/", 1, 3)
for url in url_generator:
   print(url)
#### #/product/1
#### #/product/2
#### #/product/3

-----------------------------------
# Task5

Условие: Для генерирования тестовых наборов данных вам необходимо создать функцию-генератор generate_user_data, которая принимает: размер генерируемой последовательности, список возможных имен, список возможных фамилий, диапазон возраста (список из двух чисел, включительно).

Генерируемые значения — кортеж из имени, фамилии и возраста. Данные значения должны генерироваться случайным образом (воспользуйтесь библиотекой random).

Пример работы программы:


first_names = ["Alice", "Bob", "Charlie"]
last_names = ["Smith", "Johnson", "Williams"]
user_data_generator = generate_user_data(5, first_names, last_names, [18, 60])
for user in user_data_generator:
   print(user)
#### #('Charlie', 'Williams', 19)
#### #('Charlie', 'Johnson', 48)
#### #('Bob', 'Johnson', 26)
#### #('Charlie', 'Smith', 36)
#### #('Charlie', 'Johnson', 35)

--------------------------------------